---
title: "Next.jsのSSGで全文検索をする方法"
emoji: "🗂"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["React", "Next.js",　"TypeScript", "microCMS", "AWS"]
published: false
---

# 前提
- Next.js
- TypeScript
- styled-components
- microCMS
- AWS
  - S3
  - Cloud Front
  - Route53
  
Next.jsのSSGで生成した静的ファイルをS3にアップロードして、静的なメディアサイトを作っています。
CMSはmicroCMSを利用していて、メディアの記事の部分をmicroCMSから配信しています。

# やりたいこと

Next.jsのSSGで作成した静的なメディアにおいて、全文検索機能を追加したいというのが今回のやりたかったことです。
`next dev`でローカル開発してるときは、getStaticProps内が変更はいるたびに更新され、再buildされるので、うまくいったように見えてましたが、S3にあげてみると、うまくいかなかったので、その対策をしたかったです。

# 結論

- microCMSの全文検索APIをつかう
- AWSのLambdaでエンドポイントを作成し、Next.jsからは、そのLambdaをコールし、Lambda内でmicroCMSの全文検索APIをコールすることで実現させる

# 方法

調査したところ、今回の前提条件下でNext.jsのSSGで全文検索を実現するのには、2つの方法があることがわかりました。

1. Algoliaを使用する
2. AWSのLambdaでエンドポイントを作成し、Next.jsからは、そのLambdaをコールし、Lambda内でmicroCMSの全文検索APIをコールすることで実現させる

1のAlgoliaを使用するに関しては、こちらの記事が非常にわかりやすいです。
https://fwywd.com/tech/next-algolia

Next.js開発元であるvercelのGitHubを覗いてみたところ、こちらのdiscussionにもあるようにAlgoliaを使ってみては？という提案がありました。
https://github.com/vercel/next.js/discussions/14742

今回は、2. AWSのLambdaでエンドポイントを作成し、Next.jsからは、そのLambdaをコールし、Lambda内でmicroCMSの全文検索APIをコールすることで実現させるという方法を取りました。
理由としては、すでにローカルでmicroCMSの全文検索APIを呼ぶような調査兼実装を進めていて、そこまで大きな方針転換する必要なく、実現できそうだったからです。

## 実装


```tsx:components/search.tsx

type Props = {
  submit: () => void;
}

export const Search: React.VFC<Props> = ({submit}) => {
  const [value, setValue] = React.useState('');

  const onChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setValue(e.target.value)
  }

  const onClick = () => submit(value);

  return (
    <Form>
      <Input type="text" name="search" value={value} onChange={onChange} placeholder={'検索'} />
      <TheButton onClick={onClick} >
        <img src={'/img/media/search.png'} height={16} width={16} alt={'search'} />
      </TheButton>
    </Form>
    )
}

```

```tsx:pages/index.tsx
export const Main: React.VFC<Props> = ({ articles }) => {
  const router = useRouter();
  const [data, setData] = React.useState<IMedia[]>(articles);

  const load = React.useCallback(async () => {
    const value = router.query.search as string;
    // 検索してない場合は、lambdaのURLをコールしないようにする
    // コールすればするほどお金がかかるから
    if(!value){
      setData(articles);
      return;
    }
    
    const response = await fetch("https://[lambda側で自動生成された値].lambda-url.us-east-1.on.aws/", {
      method: "POST",
      body: JSON.stringify({ query: value }),
    });
    const result = await response.json() as SearchResponse;
    if(result.totalCount === 0){
      setData(articles);
      return;
    }
    const ids = result.contents.map((r) => r.id);
    const newMedia = articles.filter((m) => ids.includes(m.id));
    setData(newMedia);
  }, [articles, router.query.search])

  const submit = React.useCallback(async (value: string) => {
    await router.push({
      pathname: '/',
      query: { search: encodeURI(value) },
    })
  }, [router]);

  React.useEffect(() => {
    load();
  } , [load])

  return (
    <>
     <ul>
       {articles.map((article, i) => <li key={i}>{article.title}</li>)}
     </ul>
     <Search submit={submit}>
    </>
  )
};

//SSG処理
export const getStaticProps: GetStaticProps<Props> = async () => {
  const data = await client.get({
    endpoint: [エンドポイント名],
  });
  return {
    props: {
      articles: data.contents,
    },
  };
};

export default Main;

```

```js:lambda

const https = require('https');

function getRequest(query) {
  const options = {
    headers: { 'X-MICROCMS-API-KEY': process.env['MICRO_CMS_API_KEY'] }
  }
  const url = `https://[サービス名].microcms.io/api/v1/[エンドポイント名]?q=${query}`
  return new Promise((resolve, reject) => {
    const req = https.get(url, options, res => {
      let rawData = '';

      res.on('data', chunk => {
        rawData += chunk;
      });

      res.on('end', () => {
        try {
          resolve(JSON.parse(rawData));
        } catch (err) {
          reject(new Error(err));
        }
      });
    });

    req.on('error', err => {
      reject(new Error(err));
    });
  });
}

exports.handler = async (event) => {
    try {
      const body = JSON.parse(event.body);
      console.log('body', body);
      const result = await getRequest(body.query);
      console.log('result is: 👉️', result);

      // 👇️️ response structure assume you use proxy integration with API gateway
      return {
        statusCode: 200,
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(result),
      };
    } catch (error) {
      console.log('Error is: 👉️', error);
      return {
        statusCode: 400,
        body: error.message,
      };
    }
};

```



