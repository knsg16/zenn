---
title: "Next.jsã®SSGã§å…¨æ–‡æ¤œç´¢ã‚’ã™ã‚‹æ–¹æ³•"
emoji: "ğŸ—‚"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["React", "Next.js",ã€€"TypeScript", "microCMS", "AWS"]
published: false
---

# å‰æ
- Next.js
- TypeScript
- styled-components
- microCMS
- AWS
  - S3
  - Cloud Front
  - Route53
  
Next.jsã®SSGã§ç”Ÿæˆã—ãŸé™çš„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’S3ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ã€é™çš„ãªãƒ¡ãƒ‡ã‚£ã‚¢ã‚µã‚¤ãƒˆã‚’ä½œã£ã¦ã„ã¾ã™ã€‚
CMSã¯microCMSã‚’åˆ©ç”¨ã—ã¦ã„ã¦ã€ãƒ¡ãƒ‡ã‚£ã‚¢ã®è¨˜äº‹ã®éƒ¨åˆ†ã‚’microCMSã‹ã‚‰é…ä¿¡ã—ã¦ã„ã¾ã™ã€‚

# ã‚„ã‚ŠãŸã„ã“ã¨

Next.jsã®SSGã§ä½œæˆã—ãŸé™çš„ãªãƒ¡ãƒ‡ã‚£ã‚¢ã«ãŠã„ã¦ã€å…¨æ–‡æ¤œç´¢æ©Ÿèƒ½ã‚’è¿½åŠ ã—ãŸã„ã¨ã„ã†ã®ãŒä»Šå›ã®ã‚„ã‚ŠãŸã‹ã£ãŸã“ã¨ã§ã™ã€‚
`next dev`ã§ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºã—ã¦ã‚‹ã¨ãã¯ã€getStaticPropså†…ãŒå¤‰æ›´ã¯ã„ã‚‹ãŸã³ã«æ›´æ–°ã•ã‚Œã€å†buildã•ã‚Œã‚‹ã®ã§ã€ã†ã¾ãã„ã£ãŸã‚ˆã†ã«è¦‹ãˆã¦ã¾ã—ãŸãŒã€S3ã«ã‚ã’ã¦ã¿ã‚‹ã¨ã€ã†ã¾ãã„ã‹ãªã‹ã£ãŸã®ã§ã€ãã®å¯¾ç­–ã‚’ã—ãŸã‹ã£ãŸã§ã™ã€‚

# çµè«–

- microCMSã®å…¨æ–‡æ¤œç´¢APIã‚’ã¤ã‹ã†
- AWSã®Lambdaã§ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ä½œæˆã—ã€Next.jsã‹ã‚‰ã¯ã€ãã®Lambdaã‚’ã‚³ãƒ¼ãƒ«ã—ã€Lambdaå†…ã§microCMSã®å…¨æ–‡æ¤œç´¢APIã‚’ã‚³ãƒ¼ãƒ«ã™ã‚‹ã“ã¨ã§å®Ÿç¾ã•ã›ã‚‹

# æ–¹æ³•

èª¿æŸ»ã—ãŸã¨ã“ã‚ã€ä»Šå›ã®å‰ææ¡ä»¶ä¸‹ã§Next.jsã®SSGã§å…¨æ–‡æ¤œç´¢ã‚’å®Ÿç¾ã™ã‚‹ã®ã«ã¯ã€2ã¤ã®æ–¹æ³•ãŒã‚ã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã—ãŸã€‚

1. Algoliaã‚’ä½¿ç”¨ã™ã‚‹
2. AWSã®Lambdaã§ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ä½œæˆã—ã€Next.jsã‹ã‚‰ã¯ã€ãã®Lambdaã‚’ã‚³ãƒ¼ãƒ«ã—ã€Lambdaå†…ã§microCMSã®å…¨æ–‡æ¤œç´¢APIã‚’ã‚³ãƒ¼ãƒ«ã™ã‚‹ã“ã¨ã§å®Ÿç¾ã•ã›ã‚‹

1ã®Algoliaã‚’ä½¿ç”¨ã™ã‚‹ã«é–¢ã—ã¦ã¯ã€ã“ã¡ã‚‰ã®è¨˜äº‹ãŒéå¸¸ã«ã‚ã‹ã‚Šã‚„ã™ã„ã§ã™ã€‚
https://fwywd.com/tech/next-algolia

Next.jsé–‹ç™ºå…ƒã§ã‚ã‚‹vercelã®GitHubã‚’è¦—ã„ã¦ã¿ãŸã¨ã“ã‚ã€ã“ã¡ã‚‰ã®discussionã«ã‚‚ã‚ã‚‹ã‚ˆã†ã«Algoliaã‚’ä½¿ã£ã¦ã¿ã¦ã¯ï¼Ÿã¨ã„ã†ææ¡ˆãŒã‚ã‚Šã¾ã—ãŸã€‚
https://github.com/vercel/next.js/discussions/14742

ä»Šå›ã¯ã€2. AWSã®Lambdaã§ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ä½œæˆã—ã€Next.jsã‹ã‚‰ã¯ã€ãã®Lambdaã‚’ã‚³ãƒ¼ãƒ«ã—ã€Lambdaå†…ã§microCMSã®å…¨æ–‡æ¤œç´¢APIã‚’ã‚³ãƒ¼ãƒ«ã™ã‚‹ã“ã¨ã§å®Ÿç¾ã•ã›ã‚‹ã¨ã„ã†æ–¹æ³•ã‚’å–ã‚Šã¾ã—ãŸã€‚
ç†ç”±ã¨ã—ã¦ã¯ã€ã™ã§ã«ãƒ­ãƒ¼ã‚«ãƒ«ã§microCMSã®å…¨æ–‡æ¤œç´¢APIã‚’å‘¼ã¶ã‚ˆã†ãªèª¿æŸ»å…¼å®Ÿè£…ã‚’é€²ã‚ã¦ã„ã¦ã€ãã“ã¾ã§å¤§ããªæ–¹é‡è»¢æ›ã™ã‚‹å¿…è¦ãªãã€å®Ÿç¾ã§ããã†ã ã£ãŸã‹ã‚‰ã§ã™ã€‚

## å®Ÿè£…


```tsx:components/search.tsx

type Props = {
  submit: () => void;
}

export const Search: React.VFC<Props> = ({submit}) => {
  const [value, setValue] = React.useState('');

  const onChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setValue(e.target.value)
  }

  const onClick = () => submit(value);

  return (
    <Form>
      <Input type="text" name="search" value={value} onChange={onChange} placeholder={'æ¤œç´¢'} />
      <TheButton onClick={onClick} >
        <img src={'/img/media/search.png'} height={16} width={16} alt={'search'} />
      </TheButton>
    </Form>
    )
}

```

```tsx:pages/index.tsx
export const Main: React.VFC<Props> = ({ articles }) => {
  const router = useRouter();
  const [data, setData] = React.useState<IMedia[]>(articles);

  const load = React.useCallback(async () => {
    const value = router.query.search as string;
    // æ¤œç´¢ã—ã¦ãªã„å ´åˆã¯ã€lambdaã®URLã‚’ã‚³ãƒ¼ãƒ«ã—ãªã„ã‚ˆã†ã«ã™ã‚‹
    // ã‚³ãƒ¼ãƒ«ã™ã‚Œã°ã™ã‚‹ã»ã©ãŠé‡‘ãŒã‹ã‹ã‚‹ã‹ã‚‰
    if(!value){
      setData(articles);
      return;
    }
    
    const response = await fetch("https://[lambdaå´ã§è‡ªå‹•ç”Ÿæˆã•ã‚ŒãŸå€¤].lambda-url.us-east-1.on.aws/", {
      method: "POST",
      body: JSON.stringify({ query: value }),
    });
    const result = await response.json() as SearchResponse;
    if(result.totalCount === 0){
      setData(articles);
      return;
    }
    const ids = result.contents.map((r) => r.id);
    const newMedia = articles.filter((m) => ids.includes(m.id));
    setData(newMedia);
  }, [articles, router.query.search])

  const submit = React.useCallback(async (value: string) => {
    await router.push({
      pathname: '/',
      query: { search: encodeURI(value) },
    })
  }, [router]);

  React.useEffect(() => {
    load();
  } , [load])

  return (
    <>
     <ul>
       {articles.map((article, i) => <li key={i}>{article.title}</li>)}
     </ul>
     <Search submit={submit}>
    </>
  )
};

//SSGå‡¦ç†
export const getStaticProps: GetStaticProps<Props> = async () => {
  const data = await client.get({
    endpoint: [ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå],
  });
  return {
    props: {
      articles: data.contents,
    },
  };
};

export default Main;

```

```js:lambda

const https = require('https');

function getRequest(query) {
  const options = {
    headers: { 'X-MICROCMS-API-KEY': process.env['MICRO_CMS_API_KEY'] }
  }
  const url = `https://[ã‚µãƒ¼ãƒ“ã‚¹å].microcms.io/api/v1/[ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå]?q=${query}`
  return new Promise((resolve, reject) => {
    const req = https.get(url, options, res => {
      let rawData = '';

      res.on('data', chunk => {
        rawData += chunk;
      });

      res.on('end', () => {
        try {
          resolve(JSON.parse(rawData));
        } catch (err) {
          reject(new Error(err));
        }
      });
    });

    req.on('error', err => {
      reject(new Error(err));
    });
  });
}

exports.handler = async (event) => {
    try {
      const body = JSON.parse(event.body);
      console.log('body', body);
      const result = await getRequest(body.query);
      console.log('result is: ğŸ‘‰ï¸', result);

      // ğŸ‘‡ï¸ï¸ response structure assume you use proxy integration with API gateway
      return {
        statusCode: 200,
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(result),
      };
    } catch (error) {
      console.log('Error is: ğŸ‘‰ï¸', error);
      return {
        statusCode: 400,
        body: error.message,
      };
    }
};

```



