---
title: "TypeScript, PostgreSQL, Next.js, Prisma & GraphQLをつかってフルスタックAppを作る"
emoji: "🦔"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["TypeScript", "PostgreSQL", "Next.js", "Prisma", "GraphQL"]
published: false
---

:::message
本記事は、[@thisismahmoud_](https://twitter.com/thisismahmoud_)氏による「[Fullstack App With TypeScript, PostgreSQL, Next.js, Prisma & GraphQL: Data Modeling](https://www.prisma.io/blog/fullstack-nextjs-graphql-prisma-oklidw1rhw)」の日本語翻訳を、Prismaから許可を得て掲載しているものです。※画像やリンクは公式のBlogからお借りしています。
:::

![](https://storage.googleapis.com/zenn-user-upload/e0f2c9ef3f57-20220416.png)

この記事は、Next.js, GraphQL, TypeScript, Prisma, PostgreSQLを使ってフルスタックアプリを構築する講座の第1部です。この記事では、データモデルを作成し、Prismaのさまざまなコンポーネントを探ります。

# はじめに

このコースでは、ユーザーがキュレーションされたリンクのリストを閲覧し、お気に入りのリンクをブックマークできるフルスタックアプリ「awesome-links」を構築する方法を学びます。

https://www.youtube.com/watch?v=hZgFAO4_t4Q

アプリは以下の技術で構築されています。

- Next.js：Reactフレームワークとして
- Apollo Server：GraphQLサーバーとして
- Nexus：GraphQLスキーマを構築する
- Apollo Client：GraphQLクライアント 
- Prisma ：マイグレーションとデータベースアクセスのためのORMである
- PostgreSQL：データベースは 
- AWS S3：画像アップロード用 
- Auth0：認証のための 
- TypeScript：プログラミング言語 
- TailwindCSS：ユーティリティ優先のCSSフレームワーク 
- Vercel：デプロイメント用

## コースで扱う内容
- Prismaを用いたデータモデリング 
- Apollo ServerとNexusを使ったNext.js APIルートのGraphQL APIレイヤーの構築 
- Apolloクライアントを使用したGraphQLのページネーション 
- Auth0を用いた認証 
- 認証 
- AWS S3による画像アップロード 
- Vercelへのデプロイメント

## 今日学べること
本講座の第1回では、まずアプリの要件定義と、Prismaを使ったデータベース層の設定を行います。

# 前提条件
https://www.youtube.com/watch?v=cwg2Vv0rJCo

## 想定される知識
このコースは、以下を前提としています。

- Node.jsの基本的な知識

- リレーショナルデータベースの基本的な理解 このコースに参加する前にデータベースについてもっと学びたい方は、Prismaのデータガイドでデータベースの仕組み、正しいデータベースの選び方、アプリケーションでデータベースを最大限に活用する方法について詳しく学んでください。
- Next.jsを使用するため、Reactの知識があることを強く推奨します。

このコースでは必要ありません。

- TypeScriptの知識（すでにJavaScriptの経験があることを前提とします
- Prismaの知識は、本講座で説明します。

最後に、このコースではデータベースとしてPostgreSQLを使用しますが、ほとんどのコンセプトはMySQLなど他のリレーショナルデータベースにも適用できます。

この記事の終わりには、データベースに接続されたNext.jsアプリが完成していることでしょう。

## 開発環境

このコースに従うには、あなたのマシンにNode.jsがインストールされている必要があります。また、PostgreSQLのインスタンスが動作している必要があります。

:::message
注：PostgreSQLはローカルに設定するか、Herokuにホスティングインスタンスを作成することができます。コースの最後のデプロイメントステップでは、リモートデータベースが必要であることに注意してください。
:::

https://www.youtube.com/watch?v=7ihvEtBAjRY

# リポジトリのクローン
この[コースの完全なソースコード](https://github.com/m-abdelwahab/awesome-links)は、GitHubで見ることができます。

:::message
注：各記事には対応するブランチがあり、順を追って読むことができるようになっています。part-1 ブランチをチェックアウトすることで、この記事と同じスタート地点に立つことができます。まず、好きなディレクトリに移動して、以下のコマンドを実行してリポジトリをクローンします。
:::

```shell
git clone -b part-1 https://github.com/m-abdelwahab/awesome-links.git
```

クローンしたディレクトリに移動して、依存関係をインストールし、開発サーバーを起動することができます。

```shell
cd awesome-links
npm install
npm run dev
```

スタータープロジェクトはこんな感じです。

![](https://storage.googleapis.com/zenn-user-upload/905d1cc430d2-20220416.png)

## プロジェクトの構成と依存関係を見る

```
awesome-links/
┣ components/
┃ ┗ Layout/
┣ data/
┃ ┗ links.ts
┣ pages/
┃ ┣ _app.tsx
┃ ┣ about.tsx
┃ ┗ index.tsx
┣ public/
┣ styles/
┃ ┗ tailwind.css
┣ .gitignore
┣ README.md
┣ next-env.d.ts
┣ next.config.js
┣ package-lock.json
┣ package.json
┣ postcss.config.js
┣ tailwind.config.js
┗ tsconfig.json
```

https://www.youtube.com/watch?v=4cpqSOQKSo8

このスタータープロジェクトは、TypeScriptとTailwindCSSをインストールしたNext.jsのアプリです。

Next.jsはフルスタックのReactフレームワークで、さまざまなデータ取得ストラテジーをサポートしています。ひとつはサーバーサイドレンダリングで、リクエストごとにデータをフェッチします。また、ビルド時にデータをフェッチして、CDNで提供できる静的なウェブサイトを用意することもできます。このアプリでは、サーバーサイドでデータを取得することになります。

Next.jsではファイルベースのルーティングを使用しており、pagesディレクトリ内の各ファイルがルートとなります。現在、http://localhost:3000 にインデックスページがあり、http://localhost:3000/about にアバウトページがあります。

_app.tsxファイルは、デフォルトのAppの動作をオーバーライドするために使用されます。このファイルでは、ページ変更時のレイアウトを保持したり、グローバルCSSを追加したりすることができます。

```tsx
// pages/_app.tsx

import '../styles/tailwind.css' // import Tailwind globally
import { Layout } from '../components/Layout' // header layout persists between page changes
function MyApp({ Component, pageProps }) {
  return (
    <Layout>
      <Component {...pageProps} />
    </Layout>
  )
}
export default MyApp
```

http://localhost:3000 にナビゲートするときに見るデータは、/data/links.ts ファイルにハードコードされています。今後のパートでは、データはGraphQL APIを使用してデータベースから動的に取得される予定です。

# アプリのデータモデルを作成する

データベースは以下のエンティティを持ち、各エンティティはデータベースのテーブルにマッピングされます。

- User: アカウントを持つ人。お気に入りのリンクをブックマークすることができ、管理者にも一般ユーザーにもなることができます。
- Link: タイトル、説明、URLなど、リンクのさまざまな属性を表現する。

- UserとLinkのエンティティの間には、多対多（m-n）の関係があります。このようにして、ユーザーは多くのリンクを持つことができ、リンクは多くのユーザーを持つことができます。

## プロジェクトにPrismaを追加する
データベースのテーブルを作成するためにPrismaを使用することにします。これは、データベースと対話するために使用できるORMです。

https://www.youtube.com/watch?v=dxnFH0qvNkU

はじめに、PrismaのCLIを開発依存でインストールします。

```shell
npm install prisma -D
```

これで、Prisma CLIを使用して、Prismaの基本的な設定を実行することで作成できます。

```shell
npx prisma init
```

新しい/prismaディレクトリが作成され、その中にschema.prismaファイルが作成されます。これはメインのPrisma設定ファイルで、データベーススキーマを格納します。.env (dotenv) ファイルもプロジェクトのルートに追加されます。ここで、データベース接続URLやアクセストークンなどの環境変数を定義します。

.envファイルを開き、ダミーの接続URLをPostgreSQLデータベースの接続URLで置き換えます。例えば、データベースがHerokuでホストされている場合、URLは以下のようになります。

```shell
// .env
DATABASE_URL="postgresql://giwuzwpdnrgtzv:d003c6a604bb400ea955c3abd8c16cc98f2d909283c322ebd8e9164b33ccdb75@ec2-54-170-123-247.eu-west-1.compute.amazonaws.com:5432/d6ajekcigbuca9"
```

:::message
注：データベースがHerokuでホストされている場合、データベースの資格情報を表示する際に、接続URLを直接コピーすることができます。
:::

先ほど追加したデータベースURLは、以下のような構造になっています。
![](https://storage.googleapis.com/zenn-user-upload/e985673ec01c-20220416.png)

| NAME | PLACEHOLDER | DESCRIPTION |
| --- | --- | --- |
| Host | HOST | IP address/domain of your database server, e.g. localhost |
| Port | PORT | Port on which your database server is running, e.g. 5432 |
| User | USER | Name of your database user, e.g. janedoe |
| Password | PASSWORD | Password for your database user |
| Database | DATABASE | Name of the database you want to use, e.g. mydb |

## Prismaでデータベーススキーマを作成する

/prisma/schema.prisma ファイルを開くと、次のようなスキーマが表示されます。

```graphql
// prisma/schema.prisma

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}
```

:::message
注）このファイルはPSL（Prisma Schema Language）を使用しています。この拡張機能は、.prismaファイルのシンタックスハイライト、フォーマット、オートコンプリート、jump-to-definition、およびlintingを追加します。
:::

datasourceフィールドでは、PostgreSQLを使用していることと、.envファイルからデータベースのURLを読み込むことを指定しました。

次に、generatorブロックでは、データモデルに基づいてPrisma Clientを生成することを指定しています。

Prisma Clientは自動生成されるタイプセーフのクエリビルダで、データベースの操作をどのように簡略化するか見ていきます。

## モデルの定義

Userモデルを作成しましょう。

```graphql
// code above unchanged
model User {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  email     String?  @unique
  image     String?
  role      Role     @default(USER)
}

enum Role {
  USER
  ADMIN
}
```

:::message
注：モデルは通常PascalCaseで綴られ、単数形を使用します。(例: userの代わりにUser、usersまたはUsers)
:::

ここでは、いくつかのフィールドを持つUserモデルを定義しています。各フィールドは、名前の後に型とオプションのフィールド属性があります。

例えば、id フィールドは String 型で、@id フィールド属性を持ち、これがテーブルの主キーであることを指定します。default(uuid())属性はUUIDのデフォルト値を設定します。

デフォルトでは、すべてのフィールドが必須です。フィールドをオプションにするには、フィールドタイプの後に「?

Role enum は、ユーザーが管理者であるか否かを示すために使用され、その後、User モデルで参照されます。

次に、Linkモデルを作成します。

```graphql
// prisma/schema.prisma
// code above unchanged

model User {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  email     String?  @unique
  image     String?
  role      Role     @default(USER)
}

enum Role {
  USER
  ADMIN
}

model Link {
  id          String   @id @default(uuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  title       String
  description String
  url         String
  imageUrl    String
  category    String
}
```

## リレーションの定義

最後に、UserモデルとLinkモデルの間に多対多の関係を作り、ユーザーが多くのリンクを持つことができ、リンクが多くのユーザーを持つことができるようにする必要があります。これは、リレーションの両側で、リレーションフィールドをリストとして定義することによって行います。

Userモデルにbookmarksフィールドを追加し、タイプはLink[]とします。次に、Linkモデルにusersフィールドを追加し、型はUser[]とします。

```diff graphql
// prisma/schema.prisma
// code above unchanged

model User {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  email     String?  @unique
  image     String?
  role      Role     @default(USER)
+ bookmarks Link[]
}

enum Role {
  USER
  ADMIN
}

model Link {
  id           String   @id @default(uuid())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  title        String
  description  String
  url          String
  imageUrl     String
  category     String
+ users        User[]
}
```

これは暗黙の多対多の関係であり、基礎となるデータベースに関係テーブルがある。このリレーションテーブルはPrismaによって管理される。

最終的なスキーマはこんな感じです。

```graphql
// prisma/schema.prisma

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  email     String?  @unique
  image     String?
  role      Role     @default(USER)
  bookmarks Link[]
}

enum Role {
  USER
  ADMIN
}

model Link {
  id           String   @id @default(uuid())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  title        String
  description  String
  url          String
  imageUrl     String
  category     String
  users        User[]
}
```