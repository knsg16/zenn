---
title: "react-konvaã§ãƒ‰ãƒ©ãƒƒã‚°æ™‚ã«ã‚·ã‚§ã‚¤ãƒ—ã®ä½ç½®ã‚’ã‚¹ãƒŠãƒƒãƒ—ã™ã‚‹æ–¹æ³•"
emoji: "ğŸ¤–"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ['typescript', 'react', 'nextjs', 'konva']
published: false
---

# ã¯ã˜ã‚ã«

ã¾ãšã¯ã€è¦‹ã¦ã‚‚ã‚‰ã£ãŸã»ã†ãŒã¯ã‚„ã„ã¨æ€ã†ã®ã§ã€ã“ã¡ã‚‰ã‚’å¾¡è¦§ãã ã•ã„ã€‚

ã“ã®ã‚ˆã†ã«ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãã‚Œã„ã«æ•´åˆ—ã•ã›ãŸã„ã¨ã„ã†æ™‚ã«ä½¿ã„ã¾ã™ã€‚


# å‰æ
- React.js
- TypeScript
- react-konva
- Konva

# ã‚¹ãƒŠãƒƒãƒ—ã¨ã¯ï¼Ÿ

ã‚¹ãƒŠãƒƒãƒ—ã¨ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®šã‚ã‚‰ã‚ŒãŸä½ç½®ã«æ­£ç¢ºã«ç§»å‹•ã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹æ©Ÿèƒ½ã®ã“ã¨ã§ã™ã€‚ä¾‹ãˆã°ã€ç·šã‚„ã‚°ãƒªãƒƒãƒ‰ä¸Šã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç§»å‹•ã•ã›ã‚‹å ´åˆã€ã‚¹ãƒŠãƒƒãƒ—ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§æ­£ç¢ºãªä½ç½®ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é…ç½®ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚


ã“ã®æ©Ÿèƒ½ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ­£ç¢ºã«ä½ç½®æ±ºã‚ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã«ç‰¹ã«æœ‰ç”¨ã§ã™ã€‚Konvaã«ãŠã„ã¦ã€ã‚¹ãƒŠãƒƒãƒ—ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«ã¯ã€ãƒ‰ãƒ©ãƒƒã‚°æ“ä½œä¸­ã«ãƒã‚¦ã‚¹ã‚«ãƒ¼ã‚½ãƒ«ã®ä½ç½®ã‚’å®šæœŸçš„ã«è¨ˆç®—ã—ã€æŒ‡å®šã—ãŸã‚°ãƒªãƒƒãƒ‰ã‚„ç·šã«å¯¾ã—ã¦æœ€ã‚‚è¿‘ã„ä½ç½®ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç§»å‹•ã•ã›ã‚‹ã‚ˆã†ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

# ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰

```tsx
import Konva from 'konva';
import React from 'react';
import { Stage, Layer } from 'react-konva';

const GUIDELINE_OFFSET = 5;

type Snap = 'start' | 'center' | 'end';
type SnappingEdges = {
  vertical: Array<{
    guide: number;
    offset: number;
    snap: Snap;
  }>;
  horizontal: Array<{
    guide: number;
    offset: number;
    snap: Snap;
  }>;
};

export const Demo: React.FC = () => {
  const stageRef = React.useRef<Konva.Stage>(null);
  const layerRef = React.useRef<Konva.Layer>(null);

  const getLineGuideStops = (skipShape: Konva.Shape) => {
    const stage = skipShape.getStage();
    if (!stage) return { vertical: [], horizontal: [] };

    // Stageã®å¢ƒç•Œã‚„ä¸­å¤®ã«ã‚¹ãƒŠãƒƒãƒ—ã§ãã¾ã™
    const vertical = [0, stage.width() / 2, stage.width()];
    const horizontal = [0, stage.height() / 2, stage.height()];

    // Canvasä¸Šã®å„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¨ãƒƒã‚¸ã‚„ä¸­å¤®ã«ã‚¹ãƒŠãƒƒãƒ—ã§ãã¾ã™
    stage.find('.object').forEach((guideItem) => {
      if (guideItem === skipShape) {
        return;
      }
      const box = guideItem.getClientRect();
      // å›³å½¢ã®ã™ã¹ã¦ã®ã‚¨ãƒƒã‚¸ã«ã‚¹ãƒŠãƒƒãƒ—ã§ãã¾ã™
      vertical.push(box.x, box.x + box.width, box.x + box.width / 2);
      horizontal.push(box.y, box.y + box.height, box.y + box.height / 2);
    });
    return {
      vertical,
      horizontal,
    };
  }

  const getObjectSnappingEdges = React.useCallback((node: Konva.Shape): SnappingEdges => {
    const box = node.getClientRect();
    const absPos = node.absolutePosition();

    return {
      vertical: [
        {
          guide: Math.round(box.x),
          offset: Math.round(absPos.x - box.x),
          snap: 'start',
        },
        {
          guide: Math.round(box.x + box.width / 2),
          offset: Math.round(absPos.x - box.x - box.width / 2),
          snap: 'center',
        },
        {
          guide: Math.round(box.x + box.width),
          offset: Math.round(absPos.x - box.x - box.width),
          snap: 'end',
        },
      ],
      horizontal: [
        {
          guide: Math.round(box.y),
          offset: Math.round(absPos.y - box.y),
          snap: 'start',
        },
        {
          guide: Math.round(box.y + box.height / 2),
          offset: Math.round(absPos.y - box.y - box.height / 2),
          snap: 'center',
        },
        {
          guide: Math.round(box.y + box.height),
          offset: Math.round(absPos.y - box.y - box.height),
          snap: 'end',
        },
      ],
    };
  }, []);

  const getGuides = React.useCallback(
    (lineGuideStops: ReturnType<typeof getLineGuideStops>, itemBounds: ReturnType<typeof getObjectSnappingEdges>) => {
      const resultV: Array<{
        lineGuide: number;
        diff: number;
        snap: Snap;
        offset: number;
      }> = [];

      const resultH: Array<{
        lineGuide: number;
        diff: number;
        snap: Snap;
        offset: number;
      }> = [];

      lineGuideStops.vertical.forEach((lineGuide) => {
        itemBounds.vertical.forEach((itemBound) => {
          const diff = Math.abs(lineGuide - itemBound.guide);
          if (diff < GUIDELINE_OFFSET) {
            resultV.push({
              lineGuide: lineGuide,
              diff: diff,
              snap: itemBound.snap,
              offset: itemBound.offset,
            });
          }
        });
      });

      lineGuideStops.horizontal.forEach((lineGuide) => {
        itemBounds.horizontal.forEach((itemBound) => {
          const diff = Math.abs(lineGuide - itemBound.guide);
          if (diff < GUIDELINE_OFFSET) {
            resultH.push({
              lineGuide: lineGuide,
              diff: diff,
              snap: itemBound.snap,
              offset: itemBound.offset,
            });
          }
        });
      });

      const guides: Array<{
        lineGuide: number;
        offset: number;
        orientation: 'V' | 'H';
        snap: 'start' | 'center' | 'end';
      }> = [];

      const minV = resultV.sort((a, b) => a.diff - b.diff)[0];
      const minH = resultH.sort((a, b) => a.diff - b.diff)[0];

      if (minV) {
        guides.push({
          lineGuide: minV.lineGuide,
          offset: minV.offset,
          orientation: 'V',
          snap: minV.snap,
        });
      }

      if (minH) {
        guides.push({
          lineGuide: minH.lineGuide,
          offset: minH.offset,
          orientation: 'H',
          snap: minH.snap,
        });
      }

      return guides;
    },
    []
  );

  const drawGuides = React.useCallback((guides: ReturnType<typeof getGuides>, layer: Konva.Layer) => {
    guides.forEach((lg) => {
      if (lg.orientation === 'H') {
        const line = new Konva.Line({
          points: [-6000, 0, 6000, 0],
          stroke: 'rgb(0, 161, 255)',
          strokeWidth: 1,
          name: 'guid-line',
          dash: [4, 6],
        });
        layer.add(line);
        line.absolutePosition({
          x: 0,
          y: lg.lineGuide,
        });
      } else if (lg.orientation === 'V') {
        const line = new Konva.Line({
          points: [0, -6000, 0, 6000],
          stroke: 'rgb(0, 161, 255)',
          strokeWidth: 1,
          name: 'guid-line',
          dash: [4, 6],
        });
        layer.add(line);
        line.absolutePosition({
          x: lg.lineGuide,
          y: 0,
        });
      }
    });
  }, []);

  const onDragMove = React.useCallback(
    (e: Konva.KonvaEventObject<DragEvent>) => {
      const layer = e.target.getLayer();

      // ç”»é¢ä¸Šã®ã™ã¹ã¦ã®ç·šã‚’å‰Šé™¤ã™ã‚‹
      layer.find('.guid-line').forEach((l: Konva.Shape) => l.destroy());

      // ã‚¹ãƒŠãƒƒãƒ—å¯èƒ½ãªãƒ©ã‚¤ãƒ³ã‚’æ¢ã™
      const lineGuideStops = getLineGuideStops(e.target as Konva.Shape);
      // ç¾åœ¨ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¹ãƒŠãƒƒãƒ—ãƒã‚¤ãƒ³ãƒˆã‚’æ¢ã™
      const itemBounds = getObjectSnappingEdges(e.target as Konva.Shape);

      // ç¾åœ¨ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¹ãƒŠãƒƒãƒ—ã§ãã‚‹å ´æ‰€ã‚’æ¢ã™
      const guides = getGuides(lineGuideStops, itemBounds);

      // ã‚¹ãƒŠãƒƒãƒ—ã§ããªã‹ã£ãŸã‚‰ã€ä½•ã‚‚ã—ãªã„
      if (!guides.length) {
        return;
      }

      drawGuides(guides, layer);

      const absPos = e.target.absolutePosition();
      // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½ç½®ã‚’å¼·åˆ¶ã™ã‚‹
      guides.forEach((lg) => {
        switch (lg.snap) {
          case 'start': {
            switch (lg.orientation) {
              case 'V': {
                absPos.x = lg.lineGuide + lg.offset;
                break;
              }
              case 'H': {
                absPos.y = lg.lineGuide + lg.offset;
                break;
              }
            }
            break;
          }
          case 'center': {
            switch (lg.orientation) {
              case 'V': {
                absPos.x = lg.lineGuide + lg.offset;
                break;
              }
              case 'H': {
                absPos.y = lg.lineGuide + lg.offset;
                break;
              }
            }
            break;
          }
          case 'end': {
            switch (lg.orientation) {
              case 'V': {
                absPos.x = lg.lineGuide + lg.offset;
                break;
              }
              case 'H': {
                absPos.y = lg.lineGuide + lg.offset;
                break;
              }
            }
            break;
          }
        }
      });
      e.target.absolutePosition(absPos);
    },
    [drawGuides, getGuides, getObjectSnappingEdges]
  );

  const onDragEnd = (e: Konva.KonvaEventObject<DragEvent>) => {
    const layer = e.target.getLayer();
    // ç”»é¢ä¸Šã®ã™ã¹ã¦ã®ç·šã‚’å‰Šé™¤ã™ã‚‹
    layer.find('.guid-line').forEach((l: Konva.Shape) => l.destroy());
  }

  React.useEffect(() => {
    const stage = stageRef.current;
    const layer = layerRef.current;

    if (!stage || !layer) return;

    // æœ€åˆã«ãƒ©ãƒ³ãƒ€ãƒ ãªé•·æ–¹å½¢ã‚’ç”Ÿæˆã—ã¾ã™
    for (let i = 0; i < 5; i++) {
      const rect = new Konva.Rect({
        x: Math.random() * stage.width(),
        y: Math.random() * stage.height(),
        width: 50 + Math.random() * 50,
        height: 50 + Math.random() * 50,
        fill: Konva.Util.getRandomColor(),
        draggable: true,
        name: 'object',
      });

      rect.on('dragmove', (e: Konva.KonvaEventObject<DragEvent>) => onDragMove(e));
      rect.on('dragend', (e: Konva.KonvaEventObject<DragEvent>) => onDragEnd(e));

      layer.add(rect);
    }

    layer.draw();
  }, [onDragMove]);

  return (
    <div style={{ backgroundColor: '#f0f0f0', width: '100vw', height: '100vh' }}>
      <Stage ref={stageRef} width={window.innerWidth} height={window.innerHeight}>
        <Layer ref={layerRef} />
      </Stage>
    </div>
  );
};


```

# è§£èª¬

1. ã‚¹ãƒŠãƒƒãƒ—ã‚¬ã‚¤ãƒ‰æ©Ÿèƒ½:
ã‚¹ãƒŠãƒƒãƒ—ã‚¬ã‚¤ãƒ‰æ©Ÿèƒ½ã¯ã€ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã€ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã®ä»–ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚„ã‚­ãƒ£ãƒ³ãƒã‚¹ã®å¢ƒç•Œç·šã«è‡ªå‹•çš„ã«å¸ç€ã™ã‚‹æ©Ÿèƒ½ã§ã™ã€‚ã“ã®ãƒ‡ãƒ¢ã§ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‚ç›´ã¾ãŸã¯æ°´å¹³æ–¹å‘ã«ã‚¹ãƒŠãƒƒãƒ—ã•ã‚Œã‚‹ã‚ˆã†ã«è¨­å®šã•ã‚Œã¦ã„ã¾ã™ã€‚

2. ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç”Ÿæˆã¨ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°:
ã“ã®ãƒ‡ãƒ¢ã§ã¯ã€5ã¤ã®ãƒ©ãƒ³ãƒ€ãƒ ãªå››è§’å½¢ãŒã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã«ç”Ÿæˆã•ã‚Œã¾ã™ã€‚ãã‚Œãã‚Œã®å››è§’å½¢ã«ã¯ã€dragmove ã‚¤ãƒ™ãƒ³ãƒˆã¨ dragend ã‚¤ãƒ™ãƒ³ãƒˆãŒè¨­å®šã•ã‚Œã¦ãŠã‚Šã€ã“ã‚Œã‚‰ã®ã‚¤ãƒ™ãƒ³ãƒˆã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‰ãƒ©ãƒƒã‚°æ“ä½œã«å¿œã˜ã¦ã‚¹ãƒŠãƒƒãƒ—ã‚¬ã‚¤ãƒ‰æ©Ÿèƒ½ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

3. ã‚¹ãƒŠãƒƒãƒ—ã‚¬ã‚¤ãƒ‰ã®æç”»:
ã‚¹ãƒŠãƒƒãƒ—ã‚¬ã‚¤ãƒ‰ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã«è¡¨ç¤ºã•ã‚Œã‚‹ç ´ç·šã§ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã©ã®ä½ç½®ã«ã‚¹ãƒŠãƒƒãƒ—ã•ã‚Œã‚‹ã‹ã‚’ç¤ºã—ã¾ã™ã€‚drawGuides é–¢æ•°ã¯ã€ã‚¹ãƒŠãƒƒãƒ—ã‚¬ã‚¤ãƒ‰ã®ç·šã‚’æç”»ã—ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¹ãƒŠãƒƒãƒ—ã•ã‚Œã‚‹ä½ç½®ã«åˆã‚ã›ã¦æ›´æ–°ã—ã¾ã™ã€‚ãƒ‰ãƒ©ãƒƒã‚°æ“ä½œãŒçµ‚äº†ã™ã‚‹ã¨ã€ã‚¬ã‚¤ãƒ‰ç·šã¯å‰Šé™¤ã•ã‚Œã¾ã™ã€‚

# Next.jsã§å‹•ã‹ã™ã«ã¯

Next.js ã¯ã€ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚° (SSR) ã¨é™çš„ã‚µã‚¤ãƒˆç”Ÿæˆ (SSG) ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ React ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€é«˜é€Ÿãªãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰ã¨ SEO ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®å‘ä¸ŠãŒæœŸå¾…ã§ãã¾ã™ã€‚ã—ã‹ã—ã€Konva ã¯ Canvas ã‚’æ“ä½œã™ã‚‹ãŸã‚ã«ãƒ–ãƒ©ã‚¦ã‚¶ã® window ã‚„ document ãªã©ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’åˆ©ç”¨ã—ã¾ã™ãŒã€ã“ã‚Œã‚‰ã¯ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã§ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚ãã®ãŸã‚ã€Next.js ã§ Konva ã‚’ä½¿ç”¨ã™ã‚‹éš›ã«ã¯ã€Dynamic import ã‚’ä½¿ã£ã¦ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã§ã®ã¿å®Ÿè¡Œã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

Dynamic import ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’é…å»¶ãƒ­ãƒ¼ãƒ‰ã—ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã§ã®ã¿å®Ÿè¡Œã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã§ã®ã‚¨ãƒ©ãƒ¼ã‚’å›é¿ã—ã€ãƒ–ãƒ©ã‚¦ã‚¶ã®ç’°å¢ƒã§æ­£å¸¸ã«å‹•ä½œã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

https://nextjs.org/docs/advanced-features/dynamic-import

ä¾‹ãˆã°ã€å…ˆã»ã©ã®ãƒ‡ãƒ¢ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ Next.js ã§å‹•ã‹ã™å ´åˆã€ä»¥ä¸‹ã®ã‚ˆã†ã« Demo ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ Dynamic import ã§èª­ã¿è¾¼ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚

```tsx
import dynamic from 'next/dynamic';

// Demo ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã§ã®ã¿å®Ÿè¡Œã™ã‚‹ã‚ˆã†ã«è¨­å®š
const DynamicDemoComponent = dynamic(() => import('./path/to/DemoComponent'), {
  ssr: false,
});

export default function MyApp() {
  return (
    <div>
      <DynamicDemoComponent />
    </div>
  );
}

```

ã“ã“ã§ã€dynamic é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ã€Demo ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã€ssr: false ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’æŒ‡å®šã—ã¦ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’ç„¡åŠ¹ã«ã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€Demo ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã§ã®ã¿å®Ÿè¡Œã•ã‚Œã€Next.js ã§æ­£å¸¸ã«å‹•ä½œã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚


# å‚è€ƒ

https://konvajs.org/docs/sandbox/Objects_Snapping.html
